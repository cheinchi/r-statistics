[["index.html", "R语言，统计学习与语言比较 Chapter 1 关于 1.1 R介绍 1.2 四则运算 1.3 向量与矩阵", " R语言，统计学习与语言比较 Jianqi 2022-10-18 Chapter 1 关于 这个是笔者在统计学习时候一些积累。 1.1 R介绍 R是一款用于统计、数据可视化的语言和环境。R是一个自由、免费、源代码开放的软件。是一个由统计计算和统计制图优秀的工具。 本书利用Rstudio中的bookdown进行编写和编译的,bookdown是由yihui所开发的一款用于编写onlinebook的模块。这本书会将日常中的一些R计算以及R绘图等操作记录下来。 在bookdown中，我们会使用到rmarkwodn，是一种可用于编辑代码与等不同的方式，不仅仅用于R同样我们还可以用于实现其他的编译软件如python等。 1.2 四则运算 5 + (2.3 - 1.125)*3.2/1.1 + 1.23E3 ## [1] 1238.418 1.2.1 乘方运算 3^3 ## [1] 27 1.2.2 数学函数 sqrt(16) ## [1] 4 sqrt(10) ## [1] 3.162278 cos(10) ## [1] -0.8390715 sin(pi/2) ## [1] 1 asin(1) ## [1] 1.570796 1.2.3 概率分布 dnorm(2,mean=0,sd=1) #parameter=x,mean=,sd= ## [1] 0.05399097 pnorm(10,1,1) ## [1] 1 1.3 向量与矩阵 R语言中以&lt;-进行赋值，向量的生成使用c()来实现。 bookdown::serve_book() 1.3.1 数值型向量 marks &lt;- c(10, 6, 4, 7, 8) x &lt;- c(1:3, 10:13) x1 &lt;- c(1, 2) x2 &lt;- c(3, 4) x &lt;- c(x1, x2) x ## [1] 1 2 3 4 8 %/% 3 #整除 ## [1] 2 5%%3 #求余数 ## [1] 2 sqrt(-1) ## Warning in sqrt(-1): NaNs produced ## [1] NaN sqrt(-1+0i) ## [1] 0+1i 1.3.2 逻辑型向量 sale&lt;-(log10(15)&lt;2); print(sale) ## [1] TRUE c(1,2,3)&gt;2 ## [1] FALSE FALSE TRUE 1:4&gt;=(4:1) ## [1] FALSE FALSE TRUE TRUE %in%是一个较为特殊的运算，x%in%y表示的是把向量y看作一个集合，运算的结果返回的是一个向量。 c(1,3)%in% c(2,3,4) ## [1] FALSE TRUE c(NA,2)%in% c(2,1,1) ## [1] FALSE TRUE which()函数返回真值对应的下标。 which(c(FALSE,TRUE,FALSE,TRUE)) ## [1] 2 4 对于一个真-假向量，只能输入这两类，输入数值型会发生报错。 identical(x,y)对两个R对象进行比较，需要确定x和y之间完全相同与否。比如在向量/矩阵中若一个元素不完全相同，则实际是不同的。 x=1;y=1 identical(x,y) ## [1] TRUE identical(c(NA,1,2),c(NA,2,2)) ## [1] FALSE X=matrix(1:9,nrow = 3,ncol = 3) Y=matrix(1:9,nrow = 3,ncol = 3) identical(X,Y) ## [1] TRUE Y2=matrix(c(1,2,3,4,5,6,7,8,8),3,3) identical(X,Y2) ## [1] FALSE all.equal()与identical()类似，但比较时候不区分数据类型。 all.equal(c(1,2,3),c(1,2,NA)) ## [1] &quot;&#39;is.NA&#39; value mismatch: 1 in current 0 in target&quot; all.equal(c(1L,2L,3L), c(1,2,3)) ## [1] TRUE duplicated()返回是是否在集合（向量）中为重复值，是否为重复值，是根据前面的进行遍历得到，若之前的数据已经检测append进入队列，再进入就是重复值。因此未出现返回FALSE，之前已经出现则TRUE。 duplicated(c(1,2,1,3,NA,4,NA)) ## [1] FALSE FALSE TRUE FALSE FALSE FALSE TRUE duplicated(c(1,2)) ## [1] FALSE FALSE unique(c(1,2,3,2,3)) ## [1] 1 2 3 unique()可将重复值去除，留下无重复数值。 1.3.3 字符型向量 s1 &lt;- c(‘abc’, ’‘, ’a cat’, NA, ‘李明’) paste()是用于连接两个字符型向量，元素可以一一对应的连接；对于数值与字符型时候，采用的是一对多的形式进行连接，自动将数值型向量转换为字符型。 paste(&quot;x&quot;,1:3) ## [1] &quot;x 1&quot; &quot;x 2&quot; &quot;x 3&quot; paste(c(&quot;ab&quot;, &quot;cd&quot;), c(&quot;ef&quot;, &quot;gh&quot;)) ## [1] &quot;ab ef&quot; &quot;cd gh&quot; 1.3.4 向量下标与子集 在这里的向量下标不同于python的数组下标，第一个元素的下标用x[1]取出，同样不同的：python用x[-1]取出最后一个元素；而R用x[-1]所取的是除去x[1]之后的元素全部取出。 R的实现： x&lt;-c(1,5,10,20,25) x[-1] ## [1] 5 10 20 25 x[-1] ## [1] 5 10 20 25 x[]表示的是全部取出作为子集，但这与x本身并不相同： x &lt;- c(1,2,3) x[]&lt;-20 x ## [1] 20 20 20 1.3.4.1 逻辑下标 x &lt;- c(1,20,50,100) x[x&gt;30] ## [1] 50 100 1.3.4.2 which() which()可用于找到想要的下标。 x &lt;- c(3, 4, 3, 5, 7, 5, 9) which(x &gt; 5) ## [1] 5 7 1.3.4.3 元素名 向量可以进行命名 attr &lt;- c(&quot;age&quot;=11,&quot;gender&quot;=0) names(attr) ## [1] &quot;age&quot; &quot;gender&quot; ages &lt;- setNames(c(30, 25, 28), c(&quot;李明&quot;, &quot;张聪&quot;, &quot;刘颖&quot;)) 这个类似于python之中的字典，在dict中的名字被称为keys-键。 tinydict = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;b&#39;: &#39;3&#39;} tinydict[&quot;a&quot;] ## 1 tinydict.keys() ## dict_keys([&#39;a&#39;, &#39;b&#39;]) "],["r初等统计分析.html", "Chapter 2 R初等统计分析 2.1 概率分布 2.2 最大似然估计(MLE) 2.3 广义线性回归 2.4 逻辑回归对数似然函数 2.5 逻辑回归的梯度下降 2.6 多重共线性 2.7 强影响点分析", " Chapter 2 R初等统计分析 2.1 概率分布 R中与xxx分布有关的函数包括： dxxx(x)， 即xxx分布的分布密度函数(PDF)或概率函数(PMF)——option加log=TRUE可计算对数密度函数 pxxx(q)， 即xxx分布的分布函数(CDF)。 qxxx(p)， 即xxx分布的分位数函数, ， 对连续型分布，， 即的解。 rxxx(n)， 即xxx的随机数函数，可以生成个xxx的随机数 2.2 最大似然估计(MLE) R函数optim()、nlm()、optimize()可以用来求函数极值， 因此可以用来计算最大似然估计。 optimize()只能求一元函数极值。 函数optim()缺省使用Nelder-Mead单纯型搜索算法， 此算法不要求计算梯度和海色阵， 算法稳定性好， 但是收敛速度比较慢。 可以用选项method=\"BFGS\"指定BFGS拟牛顿法。 这时可以用gr=选项输入梯度函数， 缺省使用数值微分计算梯度。 如： 2.3 广义线性回归 \\[ y=\\omega^Tx=b \\] 可否令模型预测值(上式中的 y，预测值)，逼近 y (真实标记，两个y含义不同)的衍生物呢？如果我们认为示例所对应的输出标记是指数尺度上变化，那我们就可以将输出标记的对数作为线性模型逼近的目标，即： \\[ \\ln y=\\omega^Tx \\] 这就是对数线性回归，实际上是在试图让\\(exp\\{w^Tx+b\\}\\)接近\\(y\\) 仍然是线性回归，但实质上是输入空间到输出空间的非线性函数映射。 更一般地，考虑单调可微函数\\(g(·)\\)，令： \\[ y=g^{-1}(w^t+b) \\] 对数线性模型是广义线性模型在\\(g(x)=\\ln(x)\\)的特例； 2.3.1 混合模型 混合模型是一个可用来表示总体分布(distribution)中含有k个子分布的概率模型，也就是说混合模型表示了观测数据在总体中的概率分布，是一个由k个子分布组成的混合分布； 2.4 逻辑回归对数似然函数 逻辑回归假设数据服从伯努利分布，通过极大化似然函数方法，在运用梯度下降算法(Gradient Descent)求解得到参数值； 梯度下降：对于一个多元连续可导函数$ f(X)\\(,在\\) x_n\\(处下降最快的就是\\)x_n$ 梯度的反方向；故迭代策略： \\[ x_{n+1}=x_n-\\alpha \\nabla f(x_n) \\] 其中$ &gt;0$控制下降步长 对数几率函数：是一种sigmoid函数，通过此函数来输出类别概率。 对数几率函数：$ y=$，其中y代表的是样本视为正样本的可能性，1-y代表的是视为负样本的可能性； 对数几率：定义为$ =w^Tx+b\\(，其中\\) $称为比率； 决策边界：作用在n维空间，将不同样本分开的平面或曲面，在逻辑回归中，决策边界$ w^Tx+b=0$ 由对数几率函数输出正样本概率，得到对应关系: $ P(y=1|x)=$ 令$ P(y=1|x)=(x)\\(则对应的\\) P(y=0|x)=$ 其中$ P(y=0|x)=1-(x)$ 导入m大小的数据集，可写出似然函数： 对数似然函数就是： 注意：在这里，$ y^{(i)}$为二分类值，同时还可以推广到多分类； 对数似然函数的对立面——损失函数 又称交叉墒损失函数，度量分布的差异性； 令$ h_(x)=$ 使用\\(\\theta\\)代替了$ [b,w_0,w_1,,w_n]$ 交叉熵损失函数： 特别地对于Bernoulli分布， $Pr(y:p)=py(1-p){1-y} $对于 $ y{0,1}$ 对数似然函数： $ l()=^N_{i=1}{y_i logP_i+(1-y_i)log(1-P_i)}$ $ P_i=1/1+exp(-(_1+2x{2_i}++px{p_i}))$ optim从initiate值开始进行迭代，所返回的值是 par作为初始值，开始迭代，返回的值是最优点点值 par元素表示最优解取值 value值表示目标函数值 counts代表调用目标函数与梯度函数的数目，可认为是迭代数目 convergence是收敛的代码 0表示成功完成了优化任务 1表示达到了达到了迭代上限而退出，关于迭代上限会在control参数的maxit元素进行说明 10表示退化(退化表示单纯型无法继续移动)的单纯型 51专指优化算法为L-BFGS-B的时候输出的警告信息。(L-BFGS-B为拟牛顿改进方法) 52专指优化算法为L-BFGS-B的时候输出的错误信息。 2.4.1 逻辑回归 glm(formula,data,family) formula表示变量之间的关系 data是给出这些变量的值的数值关系 family是R语言对象来指定模型的细节，值为二项逻辑回归 内置数据集“mtcars” 描述具有各种发动机规格的汽车的不同型号。 在“mtcars”数据集中，传输模式（自动或手动）由am列描述，它是一个二进制值（0或1）。 我们可以在列“am”和其他3列（hp，wt和cyl）之间创建逻辑回归模型。 # Select some columns form mtcars. input &lt;- mtcars[,c(&quot;am&quot;,&quot;cyl&quot;,&quot;hp&quot;,&quot;wt&quot;)] print(head(input)) ## am cyl hp wt ## Mazda RX4 1 6 110 2.620 ## Mazda RX4 Wag 1 6 110 2.875 ## Datsun 710 1 4 93 2.320 ## Hornet 4 Drive 0 6 110 3.215 ## Hornet Sportabout 0 8 175 3.440 ## Valiant 0 6 105 3.460 当我们执行上面的代码，它产生以下结果 - am cyl hp wt Mazda RX4 1 6 110 2.620 Mazda RX4 Wag 1 6 110 2.875 Datsun 710 1 4 93 2.320 Hornet 4 Drive 0 6 110 3.215 Hornet Sportabout 0 8 175 3.440 Valiant 0 6 105 3.460 2.4.2 创建回归模型 我们使用glm()函数创建回归模型，并得到其摘要进行分析。 input &lt;- mtcars[,c(&quot;am&quot;,&quot;cyl&quot;,&quot;hp&quot;,&quot;wt&quot;)] am.data = glm(formula = am ~ cyl + hp + wt, data = input, family = binomial) print(summary(am.data)) ## ## Call: ## glm(formula = am ~ cyl + hp + wt, family = binomial, data = input) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -2.17272 -0.14907 -0.01464 0.14116 1.27641 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 19.70288 8.11637 2.428 0.0152 * ## cyl 0.48760 1.07162 0.455 0.6491 ## hp 0.03259 0.01886 1.728 0.0840 . ## wt -9.14947 4.15332 -2.203 0.0276 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 43.2297 on 31 degrees of freedom ## Residual deviance: 9.8415 on 28 degrees of freedom ## AIC: 17.841 ## ## Number of Fisher Scoring iterations: 8 2.5 逻辑回归的梯度下降 2.5.1 小样本 每次拿到的数据都是一小部分的数据，小部分数据能够对所有数据有更好的代表，而最后的收敛过程很难被达到稳定的过程。 增强：收敛路径取平均值（原为不光滑）将平均值作为结果； 第三方的插件来帮助：learning rate 收敛过程， 梯度下降： calculus包，字符串输入进， gradient： 可以求导之后的表达式， deriv3 deriv : numderiv 自变量带入，赋值之后可以直接形成结果。 一个建议：现在.R文件内写代码，然后再导入\\.rmd文件中； 2.6 多重共线性 狭义的多重共线性：自变量的数据存在线性组合近似等于零，使得回归系数结果不稳定； 广义的多重：自变量之间有较强的相关性，自变量是联动的，互相之间有替代作用； summary(lm(营业额～月收入，data=resturant)) 如何识别： 两个自变量之间的相关系数显著地不等于零，这个两个自变量之间就有广义的共线性； F检验显著但单个回归系数不显著，可能是多重共线性； 如果有单个回归系数显著但是\\(F\\)检验不显著， 可能是由于多重共线性。 如果某些回归系数的正负号与通常的认识相反， 可能是由于多重共线性。 进一步确定的计量方法： 将自变量做因变量回归，得到一个复相关系数\\(R^2_i\\)，接近1时候就说明多重共线性； 令\\(x_i\\)的容忍度(tolerance)\\(1-R^2_i\\)，容忍度接近于0时候存在多重共线性； 还可以计算VIF：为容忍度的倒数 car::vif(lmrst01) 2.7 强影响点分析 删去以后严重改变参数估计值的观测； 杠杆(leverage)指的是帽子矩阵的对角线元素\\(h_{ii}\\) \\[ \\frac{1}{n}\\leq h_{ii}\\leq \\frac{1}{d_i} \\] "],["r数据类型.html", "Chapter 3 R数据类型 3.1 类型转换 3.2 R中元素属性 3.3 日期时间 3.4 因子类型 3.5 列表类型", " Chapter 3 R数据类型 R的变量可以存储多种不同的数据类型， 可以用typeof()函数来返回一个变量或表达式的类型 typeof(c(1,2,3)) ## [1] &quot;double&quot; typeof(1:3) ## [1] &quot;integer&quot; typeof(&#39;Abc&#39;) ## [1] &quot;character&quot; typeof(factor(c(&quot;gender&quot;,&quot;age&quot;,&quot;height&quot;))) ## [1] &quot;integer&quot; 而因子的类型也不是factor而是integer. 3.1 类型转换 可以使用as.xxxx()进行数据的类型的转换。是一种强制的形式。 as.numeric(c(FALSE,TRUE)) ## [1] 0 1 as.array(c(1,2,3)) ## [1] 1 2 3 3.2 R中元素属性 除了NULL以外，R的变量都可以看作是对象，都可以有属性，属性本身就是一个对象所拥有的一些性质。在R语言之中，属性是将变量看成对象后，除了存储其他的内容以外的其他附加信息。 常有的属性包括names、dim、class。对于一个变量，可以直接使用attribute()访问所有的属性。单独取出就是使用attr$xxx来实现。 x &lt;- table(c(1,2,1,3,2,1)); print(x) ## ## 1 2 3 ## 3 2 1 attributes(x) ## $dim ## [1] 3 ## ## $dimnames ## $dimnames[[1]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; ## ## ## $class ## [1] &quot;table&quot; attributes(x)$dim ## [1] 3 table()是用于输出一个自变量出现的次数。 除了上述所说的单一属性的读取方式，还可以使用attr()来实现。 x &lt;- c(1,3,5) attr(x, &quot;theta&quot;) &lt;- c(0, 1) print(x) ## [1] 1 3 5 ## attr(,&quot;theta&quot;) ## [1] 0 1 3.3 日期时间 R可以保存日期。 3.4 因子类型 3.5 列表类型 "],["r-基础操作.html", "Chapter 4 R 基础操作 4.1 基本绘图 4.2 图库 4.3 矩阵计算 4.4 markdown 输出表格 4.5 制作幻灯片 4.6 ggplot绘图 4.7 ploty绘图 4.8 数据整理 4.9 dataframe的操作", " Chapter 4 R 基础操作 4.1 基本绘图 4.1.1 颜色 R中颜色设置主要依靠grDevices包的支持，其中提供大量颜色选择函数和生成函数。 固定颜色选择函数：R提供的自带固定种类的颜色，主要是colors()以及palette()： pdf(&quot;colors-bar.pdf&quot;, height = 120) par(mar = c(0, 10, 3, 0) + 0.1, yaxs = &quot;i&quot;) barplot(rep(1, length(colors())), col = rev(colors()), names.arg = rev(colors()), horiz = TRUE, las = 1, xaxt = &quot;n&quot;, main = expression(&quot;Bars of colors in&quot; ~ italic(colors())) ) dev.off() title()函数用于添加标题，text()函数用于向图形中任意位置添加文本，mtext()函数用于向图中四条边上添加文本。 前面两个参数x和y表示图例的坐标位置（左上角顶点的坐标） legend参数通常是一个字符向量，表示图例中的文字； fill参数指定一个与图例字符向量对应的颜色向量用于在文本左边绘制一个颜色填充方块； col参数设置图例中点和线的颜色 4.2 图库 4.2.1 直方图histogram 用于展示连续数据的最好方法 $ f(x)=F’(x)=_{h} $ 4.2.2 茎叶图 同样用于展示数据密度的工具，但刻画略显粗劣； stem(x,scale=1,width=80,aton=1e-08) 参数scale控制节与节之间的长度； width控制茎叶图的宽度； 以一个整数表示后面还有多少片叶子没有被画出； head(islands,10). ## R自带的数据集 4.2.3 条形图 par(mfrow = c(2, 1), mar = c(3, 2.5, 0.5, 0.1)) mar：调整bottom左 top 右的边界宽度（以线的数量来衡量，另一个mai是以inchs来衡量，一般用mar，有default值） mfrow显示的是subsequent mfg表示在图中哪一个将会被draw在给出c(i,j)的情况下； new每叠加一次新图形，运行一次该程序命令，即可实现在原图上继续叠加数据绘图 ```r par(mfrow=c(3,3)) plot(Nile) plot(Nile) plot(Nile) plot(Nile) plot(Nile) plot(Nile) plot(Nile) plot(Nile) plot(Nile) 2、使用split.screen() split.screen(c(2,1)) # split display into two screens ## [1] 1 2 split.screen(c(1,3), screen = 2) # now split the bottom half into 3 ## [1] 3 4 5 screen(1) # prepare screen 1 for output plot(10:1) screen(4) # prepare screen 4 for output plot(10:1) close.screen(all = TRUE) # exit split-screen mode split.screen(c(2,1)) # split display into two screens ## [1] 1 2 split.screen(c(1,2),2) # split bottom half in two ## [1] 3 4 plot(1:10) # screen 3 is active, draw plot erase.screen() #forgot label, erase and redraw plot将图重叠在一个坐标系内的方法： m = 0 sigma = 1 t = seq(-10,10,by=0.1) n1 = 1 / sqrt(2 * pi * sigma) * exp(-(t - m)^2/(2*sigma) ) plot(t,n1) par(new=TRUE) sigma = 2 n2 = 1 / sqrt(2 * pi * sigma) * exp(-(t - m)^2/(2*sigma) ) plot(t,n2) plot(x1,x2,xlab=&quot;维度&quot;,ylab=&quot;物种多样性数量&quot;); #做散点图 lines(lowess(x1,x2),col=2); #利用lowess做回归曲线 par(new=TRUE) # 是否叠加新图形，没叠加一次运行一次该命令 plot(x3,x4,yaxt=&quot;n&quot;,xaxt=&quot;n&quot;,xlab=&quot;维度&quot;,ylab=&quot;物种多样性数量&quot;); #做散点图 lines(lowess(x1,x2),col=2,lty=4); #利用lowess做回归曲线 hist(v,main,xlab,xlim,ylim,breaks,col,border) v - 是包含直方图中使用数值的向量。 main - 表示图表的标题。 col - 用于设置条的颜色。 border - 用于设置每个栏的边框颜色。 xlab - 用于描述x轴。 xlim - 用于指定x轴上的值范围。 ylim - 用于指定y轴上的值范围。 breaks - 是用来提及每个栏的宽度。 4.2.4 箱线图 R中相应的函数为boxplot() #default usuage usage(boxplot.default) #formula usuage usage(graphics:::boxplot.formula) boxplot()是一个泛型函数，可以适应不同的参数类型。 notch是一个有用的逻辑参数，决定是否在箱子上画凹槽，凹槽所表示的是中位数的一个区间估计，其计算式： \\[ Q_2+/-1.58\\mathrm{IQR}/\\sqrt{n} \\] 区间的置信水平为95%，在比较两组数据中位数差异时候，只需要箱线图的凹槽是否有重叠部分就行； boxplot(count ~ spray, data = InsectSprays, col = &quot;lightgray&quot;, horizontal = TRUE, pch = 4) ggplot(aes(y = count, x = spray), data = InsectSprays) + geom_boxplot(outlier.shape = 4) + coord_flip() 4.2.5 散点图 散点图通常用于表示两个变量之间的关系； 图中每一个点的横纵坐标都分别对应两个变量各自的观测值，因此散点所反映出来的趋势也就是两个变量之间的关系； R中散点图的函数为plot.default()但由于plot()是泛形，通常只需要提供两个数值型向量给plot()即可； 4.2.6 关联图 关联图是展示二维列联表数据的一种工具，主要基于列联表的独立性检验理论生成的图形； 对于一个\\(r\\times c\\)列联表，\\[ \\chi^{2} \\]统计量的定义为如下平方和形式： 其中，\\(f_{ij}\\)为单元格中观测频数，\\(e_{ij}\\)为期望频数；两者相差越大，则会导致检验统计量的值越大，说明行变量和列变量越不独立； R中关联图的函数assocplot() assocplot(x, col = c(&quot;black&quot;, &quot;red&quot;), space = 0.3, main = NULL, xlab = NULL, ylab = NULL) 4.2.7 条件密度图 条件密度图：展示的是一个变量的条件密度，或一个分类变量\\(Y\\)相对于一个连续变量\\(X\\)的条件密度\\(P(Y|X)\\)； ## ## Default S3 method: cdplot(x, y, plot = TRUE, tol.ylab = 0.05, ylevels = NULL, bw = &quot;nrd0&quot;, n = 512, from = NULL, to = NULL, col = NULL, border = 1, main = &quot;&quot;, xlab = NULL, ylab = NULL, yaxlabels = NULL, xlim = NULL, ylim = c(0, 1), ...) par(mar = rep(0, 4)) # 继续前面的例子 persp(est$x1, est$x2, est$fhat, shade = 0.75, border = NA, col = &quot;lightblue&quot;, phi = 20, theta = 15, box = FALSE) 4.2.8 条件分割图 给定某一个或几个变量之后看所关心的变量的分布情况，分布主要指两个变量之间的关系，通常以散点图的形式展开： 分割图的函数： coplot() 4.2.9 坐标轴须 4.3 矩阵计算 4.3.1 求特征向量 eigen(A) 4.3.2 伴随矩阵计算 det(A)*solve(A) 4.3.3 矩阵求秩 qr(A)$rank # or qr.default(A)$rank 4.3.4 矩阵求迹 sum(diag(A)) 4.3.5 矩阵求幂 2^A expm(A) 4.3.6 单位矩阵 diag(rep(3)) rep(1,3) %o% rep(1,3) 4.3.7 对角矩阵 diag(A) diag(diag(A)) colsums计算矩阵的列和，返回值为列的和，与所取矩阵及其范围相关 rowsums计算的是矩阵的各行的和； colMeans(A)求各行的均值 求和： rowSums()# 对于多列的进行求和； sum() 4.4 markdown 输出表格 x &lt;- 1:10; y &lt;- x^2; lmr &lt;- lm(y ~ x) co &lt;- summary(lmr)$coefficients print(co) knitr::kable(co)来表示表格 tidy=TRUE重排代码块——更好看 cache=TRUE缓存上次运行的结果 4.4.1 章节目录 ### 第三章第一节标题 {#c3-s1-int} 还有一种可以不显示到或不link到目录的： ## 摘要 {.unnumbered #abstract} 4.4.2 rmarkdown主题设置 template包内部有不同的方法来实现； 4.4.3 YAML元数据 可以在Rstudio中编辑markdown文件与 --- title: &quot;临时测试&quot; author: &quot;黄建祺&quot; date: &quot;2016年7月6日&quot; --- 冒号:在属性设置中有特殊意义， 属性设置值如果含有冒号， 需要把整个属性值两边用单撇号界定。 4.4.4 data.frame转换为列表的形式 &gt; library(pacman) &gt; p_load(tidyverse) &gt; df &lt;- read.csv(&quot;./data_set/store-reliab-data.csv&quot;, header = T) %&gt;% as_tibble &gt; str(df) 4.5 制作幻灯片 Rmd文件选用输出格式slidy_presentation可以生成网页格式的幻灯片， 并具有缩放字体大小、显示幻灯片目录等功能。 只要在.Rmd文件开头的YAML元数据部分指定output: slidy_presentation。 因为幻灯片的单位是帧(frame)， 与论文的结构有很大区别， 所以幻灯片Rmd文件很难同时作为论文的源文件。 4.5.1 生成网页html 形式 rmarkdown::render(&quot;mydemo.Rmd&quot;, output_file=&quot;handout.html&quot;, output_format=&quot;html_document&quot;, encoding=&quot;UTF-8&quot;) 4.5.2 在Yaml中的设置： 使得数学公式在local mathjax库打开： --- title: &quot;R幻灯片演示样例&quot; output: slidy_presentation: mathjax: local --- 4.5.2.1 output layout MS ppt --- output: powerpoint_presentation: slide_level: 2 --- 其中slide_level用来规定几级标题开始新的一帧。 theme指定一种主题， colortheme指定一种配色方案， in_header在LaTeX导言部分插入preamble.tex 4.5.3 Xaringan包的使用 ①用markdown语法：三个短横线来开始一页新的幻灯片，可以用一个井号开始写标题（标题不是必须元素）； ②可以用两个短横线分割当前页面，两短横线下面的内容会被接续上面的内容生成在下一页上，比如你有一个三个项目的列表，中间用两短横线分割，最后出来的效果就是先显示第一项，翻下一页继续显示下一项； ③用三个问号添加slide的注释，注释只显示给pre者 进一步了解所有可能的选项，?xaringan::moon_reader 打开Rprofile的方式： usethis::edit_r_profile() 对于options(servr.daemon = TRUE)要记得写入~./Rprofile ppt属性设置 class 类属性用来设置CSS类，可用于调整ppt内文字的位置 background-image 背景设置 插入数学公式 插入R代码 # 一个无聊的回归模型 fit = lm(dist~l+speed,data=cars) coef(summary(fit)) dojutsu = c(&#39;di&#39;,&#39;tian&#39;,&#39;tu&#39;,&#39;shen&#39;,&#39;zuo&#39;) grep(&#39;tian&#39;,dojutsu,value=TRUE) 插入R图形 用plot函数等方式来实现； 4.6 ggplot绘图 4.6.1 final plot par(mar = c(5, 5, 3, 5)) plot(beaver1[1:100, 3], type =&quot;l&quot;, ylab = &quot;beaver1 temperature&quot;, main = &quot;Beaver Temperature Plot&quot;, xlab = &quot;Time&quot;, col = &quot;blue&quot;) par(new = TRUE) plot(beaver2[,3], type = &quot;l&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, ylab = &quot;&quot;, xlab = &quot;&quot;, col = &quot;red&quot;, lty = 2) axis(side = 4) mtext(&quot;beaver2 temperature&quot;, side = 4, line = 3) legend(&quot;topleft&quot;, c(&quot;beaver1&quot;, &quot;beaver2&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = c(1, 2)) 5、其他 tick取FALSE时，坐标轴线和刻度线不画出； lty表示线型，用在axis函数中表示坐标轴线型； lwd表示线的粗细，用在axis函数中表示坐标轴线粗细； lwd.ticks表示刻度线粗细。 at表示坐标轴刻度的位置，可以自己指定，比如at=c(1,2,3,4,5,5.5,5.6,6,7) labels表示与坐标轴刻度相对应的坐标轴标记，如labels=c(1,2,3,4,5,5.5,5.6,6,7)。如果要改变坐标轴，首先在画图的时候不需要把坐标轴画出来，然后再用axis加上去。如下： plot(x,y,xaxt=“n”) axis(side=1,at=c(….),labels=c(…)) 下面是axis（）的完整参数列表，各个参数的详细含义见R。 axis(side, at = NULL, labels = TRUE, tick = TRUE, line = NA, pos = NA, outer = FALSE, font = NA, lty = &quot;solid&quot;, lwd = 1, lwd.ticks = lwd, col = NULL, col.ticks = NULL, hadj = NA, padj = NA, ...) 参数 描述 side 一个整数，表示在图形的哪边绘制坐标轴（1=下，2=左，3=上，4=右） at 一个数值型向量，表示需要绘制刻度线的位置 labels 一个字符型向量，表示置于刻度线旁边的文字标签（如果为 NULL，则将直接使用 at 中的值 tick 一个逻辑值，指定是否应绘制刻度线和轴线 line 到轴线的行数距离 pos 坐标轴线绘制位置的坐标（即与另一条坐标轴相交位置的值） outer 一个逻辑值，指示是否应在外部绘图边距而非标准绘图边距中绘制轴 font 文字的字体 4.7 ploty绘图 ploty绘图是可互动的； 基本绘图命令：plot_ly(data, x, y, z, type, mode...) 其中: x：x轴数据 y ：y轴数据 z： z轴数据 text： 文本内容——在每一个点中的具体内容中进行显示 name： 名称，图注中使用 alpha：透明度 size： 点的大小 linetype： 线的类型 color：图形颜色 symbol：指定形状 stroke：边框颜色 showlegend： bool value 4.7.1 散点图 指定参数add_trace(…,type=“scatter”,mode=“”) %&gt;%等同于ggplot中的+ 进一步进行拓展：将mode改为lines或其他的模式；同时还可以mode 内将多个模式联合使用； 气泡图：就是将点的大小和颜色与其他特征联系起来（bubble）——选择type时候仍然是选择`scatter 哑铃图, 将起始点与终止点用segment连接起来 (Dumbbell) 包含的trace: marker, line 4.7.2 柱类型（柱状图、堆积图、直方图、瀑布图……） 4.7.2.1 柱状图(Bar Charts) 指定参数add_trace(...,type=\"bar\")（等同于add_bars） 要么用通用的add_trace&amp;type=“ ”，要么使用add_bars marker传入列表包括柱子的特征，line指定边框颜色粗细，color柱子颜色，opacity指定柱子的透明度； layout对于柱状图的设置 barmode: 设置直方图的展示形式, 可选参数: “stack” (堆叠展示) | “group” (分组展示) | “overlay” (覆盖展示) | “relative” (相对高度) (Default: “group”) bargap: 每个柱子的间隔 barnorm: bar的标准化形式, 可选参数: “” | “fraction” (分数) | “percent” (百分数) (Default: ““) bargap: 设置相邻位置坐标 (不同特征) bar之间的间距 (0 ~ 1的区间) bargroupgap: 设置相同坐标 (相同特征) bar之间的间距 (0 ~ 1的区间) (Default: 0) 直方图 (Histgram) 指定参数add_trace(...,type=\"historm\") opacity: 柱子的透明度, 0 ~ 1的区间 (Default: 1) histfunc: 每一个柱子的统计指标: “count” (默认) | “sum” | “avg” | “min” | “max” histnorm: 指定用于此直方图规格化类型: “” (默认) | “percent” | “probability” | “density” | “probability density” marker: 传入列表参数, 指定直方图中柱子的特征 library(plotly) ay &lt;- list( tickfont = list(color = &quot;red&quot;), overlaying = &quot;y&quot;, side = &quot;right&quot;, title = &quot;second y axis&quot;) fig &lt;- plot_ly() fig &lt;- fig %&gt;% add_lines(x = ~1:3, y = ~10*(1:3), name = &quot;slope of 10&quot;) fig &lt;- fig %&gt;% add_lines(x = ~2:4, y = ~1:3, name = &quot;slope of 1&quot;, yaxis = &quot;y2&quot;) fig &lt;- fig %&gt;% layout( title = &quot;Double Y Axis&quot;, yaxis2 = ay,xaxis = list(title=&quot;x&quot;)) fig 4.8 数据整理 4.8.1 数据结构 数组元素的排列次序缺省情况下是采用第一下标变化最快，最后下标变化最慢的顺序存放的；对于矩阵（二维数组）则是按列存放。例如，假设数组a的元素为1:24，维数向量为c(2,3,4)，则各元素次序为a[1,1,1], a[2,1,1], a[1,2,1], a[2,2,1], a[1,3,1], …, a[2,3,4]。 数组的访问 矩阵的生成与存储 matrix(data=NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) 生成一堆NA（表示无数据的）来进行生成矩阵 cbind：根据列进行合并， rbind：根据矩阵的行进行合并 4.8.2 tibble数据结构(记得进一步补充) 一种改进的数据框 用as_tibble()可以将一个数据框转换为tibble, dplyr包提供 列表类型的列： tibble(x = 1:3, y = list(1, 1:2, 1:3)) 在不写全工作路径情况下，默认为当前的工作路径下读取数据。 每一个对象都有属性：元信息描述对象的特性。属性能通过attributes()函数罗列出来并能通过attr()函数进行设置。 R函数使用关于对象类的信息来确定如何处理对象。可以使用class()函数来读取和设置对象的类。 x &lt;- c(apple=2.5,orange=2.1) attributes(x)#返回对象x的各特殊属性组成的列表，不包括固有属性mode和length mode(x) length(x) 可以用attr(object,name)的形式存取对象object的名为name的属性。如： attr(x,“names”) 也可以把attr()函数写在赋值的左边以改变属性值或定义新的属性，如: attr(x,“names”) &lt;- c(“apple”,“grapes”) eval(expr) ls() 来查看工作空间； rm删除工作空间的变量； 数据集经常需要选行子集、选列子集、排序、定义新变量、横向合并、长宽转换等操作， R的管道运算符|&gt;和magrittr包的|&gt;特别适用于这种分步处理。 4.8.2.1 Utilas 包内的head 选择前几个数据的方式来过滤： d.class |&gt; #使用管道来进行传输过滤 head(n=5) |&gt; knitr::kable() 4.8.3 sample_n对样本进行抽样 d.class |&gt; sample_n(size = 3) |&gt; knitr::kable() 4.8.4 使用arrange进行排序 d.class |&gt; arrange(sex, age) |&gt; knitr::kable() 类似于stata 可以将变量重命名 4.8.5 利用mutate进行重新计算 d.class |&gt; mutate( rwh=weight/height, sexc=ifelse(sex==&quot;F&quot;, &quot;女&quot;, &quot;男&quot;)) |&gt; head(n=3) |&gt; knitr::kable() 4.9 dataframe的操作 创建较为简易：直接调用data.frame函数就行 4.9.1 查询 查询某一行或某一列 可通过dataframe_name[row，]或dataframe_name[,column] 还可通过dataframe_name$column_name实现 若要查找符合条件的行，可采用which()函数，得到的类型为数据框； 查询某一个值，可通过data.frame[row,column]实现 which函数同样可以实现查找符合条件的值 4.9.2 修改 直接导入向量数据 df[1,] &lt;- c(1,2,3…,) 修改某一个值，直接调出精确位置df[row,column]再进行赋值； 修改行列名 4.9.3 删除 删除行或列，仅需要选出该数据框的部分行或列，然后再将其赋给该变量即可，其中在列好或行号前添加。 4.9.4 添加 添加行 data.frame[new_row, ]&lt;- value 还可以使用dplyr包内的mutate() mutate(df,c=m+n+…+z) group_by()函数，用于对不同的分组进行操作 %&gt;%管道函数，将左侧的值传送给右边的表达式中，作为右侧的第一个函数的第一个参数； Summarize()概括dataframe的情况 filter：过滤数据的基本操作 如果想删除一部分无效或者根本不感兴趣的数据。 dplyr有filter（）函数来做这样的过滤。 使用dplyr，可以帮助使用者像使用SQL或者传统BI工具以简单且更直观的方式进行过滤。 d.class |&gt; filter(sex==&quot;F&quot;, age&lt;=13) |&gt; knitr::kable() 同时还可以将这些数据传递给knitr ::kable() 生成数据框 同时也可以直接命名一个变量传递给变量 select() 可以用于生成一个新的数据框 可直接新生成变量，然后再筛选数据： data2$Gender[which(data2$Gender ==&#39;F&#39;)] &lt;- &#39;W&#39; 4.9.5 tidyverse系统 purrr包可以方便列表操作 Pluck() :同[[提取列表中的元素 keep()： 保留满足条件元素 discard(): 删除满足条件元素 compact(): 删除空元素 append(): 列表末尾增加元素 flatten(): 数据框是由列向量组成，有着矩阵形式的列表； 数据框每一列代表一个变量属性，一行一个样本数据； tibble()不改变输入变量的类型，不创建行名； tibble输出时候不自动显示所有行，避免大数据框时显示很多内容 []选取子集，返回的仍然是tibble; 4.9.5.1 提取数据框的元素、子集 列向量，有矩阵形式的列表 列表方式提取数据框的元素、子集——沿用dataframe的方法基础上还可以用列表的方法 用[]提取数据框的一列或多列， 4.9.5.2 给数据框赋值 以列表方式 用$ 或[[]]对数据框的一列赋值 利用现有列，创建（计算）新列 用[]对数据框的一列或多列进行赋值； 以矩阵方式 str()或glimpse()作用在R对象上，显示该对象结构 summary()作用在数据框/列表上，生成各列/成分的汇总信息 多个数据框 rbind() cbind() 4.9.6 中文字体的使用 library(showtext) showtext.auto(enable=TRUE) font.add(&#39;SimSun&#39;, regular = &#39;/Library/Fonts/Microsoft/SimSun.ttf&#39;) json是javaScript object notation简称，一种轻量化的数据表示方式，采用key：value的形式记录数据，直观，比XML简洁； &lt;request&gt; &lt;firstName&gt;Brett&lt;/firstName&gt; &lt;lastName&gt;McLaughlin&lt;/lastName&gt; &lt;email&gt;brett@newInstance.com&lt;/email&gt; &lt;/request&gt; par的使用：每一个图形都有自己的参数，就是在图形还没绘制完成前，打开一个新的绘图设备。 https://blog.csdn.net/heidlyn/article/details/54581605 "],["cross.html", "Chapter 5 Cross-references 5.1 Chapters and sub-chapters 5.2 Captioned figures and tables", " Chapter 5 Cross-references Cross-references make it easier for your readers to find and link to elements in your book. 5.1 Chapters and sub-chapters There are two steps to cross-reference any heading: Label the heading: # Hello world {#nice-label}. Leave the label off if you like the automated heading generated based on your heading title: for example, # Hello world = # Hello world {#hello-world}. To label an un-numbered heading, use: # Hello world {-#nice-label} or {# Hello world .unnumbered}. Next, reference the labeled heading anywhere in the text using \\@ref(nice-label); for example, please see Chapter 5. If you prefer text as the link instead of a numbered reference use: any text you want can go here. 5.2 Captioned figures and tables Figures and tables with captions can also be cross-referenced from elsewhere in your book using \\@ref(fig:chunk-label) and \\@ref(tab:chunk-label), respectively. See Figure 5.1. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 5.1: Here is a nice figure! Don’t miss Table 5.1. knitr::kable( head(pressure, 10), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 5.1: Here is a nice table! temperature pressure 0 0.0002 20 0.0012 40 0.0060 60 0.0300 80 0.0900 100 0.2700 120 0.7500 140 1.8500 160 4.2000 180 8.8000 "],["随机模拟.html", "Chapter 6 随机模拟 6.1 高维定积分 6.2 从未知分布中采样 6.3 Metropolis algorithm 6.4 Metropolis-Hastings algorithm 6.5 马尔可夫迭代 6.6 Gibbs采样 6.7 重要采样法 6.8 分层抽样法", " Chapter 6 随机模拟 模拟是指把某一现实的或抽象的系统的某种特征或部分状态， 用另一系统（称为模拟模型）来代替或模拟。 某些非随机的问题也可以通过概率模型引入随机变量， 化为求随机模型的未知参数的问题。 例10.1中用随机投点法估计就是这样的一个例子。 随机模拟积分也称为蒙特卡洛积分（MC积分） set.seed(1) I.true&lt;-2^(3/4)*gamma(5/4)/sqrt(pi) N=10000 yvec=abs(rnorm(N))^1.5 I.hat=mean(yvec) sd.hat&lt;-sd(I.hat) sd.hat ## [1] NA I.residual&lt;-I.true-I.hat 对于随机模拟的一些问题可以看成是\\(\\theta=EY\\)的问题，设\\(Var(\\theta)=\\sigma^2\\)，生成样本独立同分布的\\(Y_i,i=1,2\\cdots,N\\)用 \\[ \\hat \\theta=\\overline Y_N=\\frac{1}{N}\\sum^N_{i=1}Y_i \\] 来估计\\(\\theta\\) \\(EY=\\overline Y_N\\)时候，可以利用近似正态分布\\(N(\\theta,\\sigma^2/N)\\) 其中\\(\\sigma^2\\)又可以用\\(S_N^2\\)来近似得到： \\[ \\frac{\\hat \\theta-\\theta}{S_N/\\sqrt{N}}\\xrightarrow d N(0,1) \\] 而同时对于估计\\(\\hat\\theta\\)中存在随机误差，度量方法： \\[ RMSE=\\sqrt{E(\\hat \\theta-\\theta)^2} \\] \\(E(\\hat \\theta)=\\theta\\)故均方根误差RMSE： \\[ RMSE=\\frac{\\sigma}{\\sqrt{N}} \\] 平均绝对误差： \\[ MAE=E|\\hat \\theta-\\theta|=\\frac{\\sigma}{\\sqrt{N}}E|\\frac{\\hat \\theta-\\theta}{\\sigma \\sqrt{N}}| \\] 6.1 高维定积分 计算一元的方法容易推广到多元的形式上； 设d元超矩形\\(h(x_1,x_2,\\cdots,x_d)\\)定义于超矩形 \\[ C=\\{(x_1,x_2,\\cdots,x_d)\\}:a_i\\leq x_i \\leq b_i,i=1,2,3\\cdots,d \\] 同时函数有界； 对采样的理解:知道了一个变量的分布，要生成一批样本服从这个分布，这个就叫做采样； 定义：抽样从总体选择一组（样本），再从中收集可用于研究的数据。 总体(population)是从中抽取统计样本进行研究的元素或个体资源的集合； 6.2 从未知分布中采样 6.2.1 直接抽样 直接使用均匀分布； 通过对均匀分布的变换得到任意分布，间接的实现对其的采样； 变换方法：采用逆CDF变换法 假设x的概率密度为$ f(x)$ ，累计分布函数CDF为$ F(x)$，可通过以下步骤来得到非均匀随机样本：相当于已知y，通过反函数来求得x的对应值（一般只是适用于CDF，单调不减函数，可形成一一映射） 使用合适的PRNG（随机数生成器）从均匀分布采样\\(Z～U(0,1)\\)； 令$ X=F^{-1}(Z)\\(，X可认为是根据\\) f(X)$得到的样本； [公式] [公式] 6.2.2 接受-拒绝抽样算法 v2-81ad256d0db58e18d2e2792c3968d57b_1440w （之前一直困惑于怎么能够在每一个点找到对应的$ \\(去对应上目标密度）\\) \\(是我们需要在每一个点所确定的，同时\\) \\(也还是由[0,1]均匀分布生成的（与\\)$一一对应），因此这个思路就是落在目标分布内的accept，落在目标分布外的refuse； 一个直观的解释 6.2.3 间接抽样 6.2.4 MCMC采样 MC蒙特卡罗和马尔科夫 蒙特卡洛方法：给定概率分布$ p(x)$，通过抽样获得概率分布的随机样本，蒙特卡洛的核心就是随机抽样； 当\\(n\\)足够大时，可用均值近似$ _{i=1}^n $，这个就是蒙特卡罗方法的一般形式； 一般：目标平稳分布\\(\\pi(x)\\)和某一个马尔科夫链状态矩阵\\(Q\\)不能满足细致平稳条件： \\[ \\pi(i)Q(i,j)\\neq \\pi(j)Q(j,i) \\] 因此要使得等式两侧相等：引入\\(\\alpha (i,j)\\)——总是被称为接受率 \\[ \\pi(i)Q(i,j)\\alpha(i,j)=\\pi(j)Q(j,i)\\alpha(j,i) \\] 由此又固定了马氏链矩阵\\(P(i,j)=Q(i,j)\\alpha(i,j)\\) v2-48086a0f62774d98f6b672b91d2dcda0_1440w 6.2.5 算法 输入任意给定的马尔科夫链状态转移矩阵Q，目标平稳分布\\(\\pi(x)\\)，设定状态转移方程阀值\\(n_1\\)，需要的样本数\\(n_2\\)； 从任意简单概率分布得到初始值\\(x_0\\) for t=0 in n_1+n_2-1 截屏2022-05-26 12.00.46 这个采样较难在实际中得到应用，\\(\\alpha(x_t,x_*)\\)可能很小，导致大部分的采样值都被拒绝转移；采样效率低下； 6.3 Metropolis algorithm system statement s:系统中所有\\(n\\)个变量的取值组合，即 \\[ s_i=[x_{1,i},x_{2,i},\\cdots,x_{m,i}] \\] 状态概率\\(\\pi\\)：处于状态\\(s_i\\)的概率\\(\\pi_i\\) 状态转移概率矩阵P：若不同状态之间的转移视为一个随机过程，其状态转移使用概率矩阵\\(P\\)表示，其中\\(P_{i,j}\\)表示过程从\\(i\\)到状态\\(j\\)的概率 \\[ \\sum_{j=1}^mP_{i,j}=1,for any i\\in [1,m] \\] Markov链平稳性：对于一条非周期的Markov链，其任意两个状态保持联通，经过有限次数的转移可以达到，则存在一下的极限： \\[ \\lim_{t\\to \\infty}P^t_{i,j}=\\pi_j \\] img 6.4 Metropolis-Hastings algorithm 对于Metropolis算法的改进：接受概率\\(\\alpha\\)可能很小，导致算法需要经历很多次的迭代才能达到平稳，MH就讲等式两侧的接受概率进行放大，将其中一个设置为1，就能保证每次迭代中接受新状态的概率越大，加速收敛； \\[ a_{j,i}=min\\{1,\\frac{\\pi_jQ_{i,j}}{\\pi_iQ_{j,i}}\\} \\] https://zhuanlan.zhihu.com/p/37121528 https://cosx.org/2013/01/lda-math-mcmc-and-gibbs-sampling 统计学和机器学习：目的在于基于数据对概率分布的特征进行推断(induction)。 一般的均匀分布$ Uniform(0,1)$相对容易生成，进一步通过线性同余发生器生成伪随机数 sampling 6.4.1 一个概率分布样本 离散or连续都可以通过均匀分布的样本生成：如正态分布通过Box-Muller变换得到： Box-muller： \\[\\begin{align*} Z_0 &amp; = \\sqrt{-2\\ln U_1} cos(2\\pi U_2) \\\\ Z_1 &amp; = \\sqrt{-2\\ln U_1} sin(2\\pi U_2) \\end{align*}\\] \\(Z_0,Z_1\\)独立且服从正态分布； 其余的几个分布：指数分布，Gamma分布，t分布等都是可以通过类似的数学变换得到；离散的分布通过均匀分布更加容易生成； MH采样：解决关于MCMC采样接受率过低的问题； https://theclevermachine.wordpress.com/2012/11/05/mcmc-the-gibbs-sampler/ [公式] 两边都进行扩大，细致平稳条件满足； 将等式扩大到C倍，使得\\(C\\alpha(j,i)=1\\)（最大扩大为1） 截屏2022-06-08 01.54.36 提高了采样中的跳转接受率 \\[ \\alpha(i,j)=\\min\\{\\frac{\\pi(j)Q(j,i)}{\\pi(i)q(i,j)},1\\} \\] 算法： 输入任意给定的马尔科夫链状态转移矩阵\\(Q\\),目标平稳分布\\(\\pi(x)\\)，状态转移次数阀值\\(n_1\\)需要样本数\\(n_2\\) 从任意简单概率的分布得到初始值\\(x_0\\) for t=0 in \\(n_1+n_2-1\\) 从条件概率分布\\(Q(x|x_t)\\)得到样本值\\(x_*\\) 从均匀分布中采样\\(U～[0,1]\\) 6.5 马尔可夫迭代 6.5.1 马尔科夫链 假设某一时刻的状态转移概率只依赖于其前一个状态： \\[ P(X^{t+1}|X,\\cdots,X^t)=P(X^{t+1}|X^t) \\] 状态转移矩阵也可求解： \\[ \\pi_i =(Pr(X_i=0|X_0),Pr(X_i=1|X_0)) \\] 最终得到的状态 $ $是该马尔可夫链的平稳分布 6.5.2 马尔可夫采样 细致平稳性条件 若非周期马尔科夫链状态转移矩阵\\(P\\)和概率分布\\(\\pi(x)\\)对所有的\\(i,j\\)满足： \\[ \\pi(i)P(i,j)=\\pi(j)P(j,i),for all i,j \\] 只要我们找到了可以使概率分布\\(\\pi(x)\\) 满足细致平稳分布的矩阵\\(P\\) 即可。这给了我们寻找从平稳分布 \\(\\pi\\) , 找到对应的马尔科夫链状态转移矩阵 \\(P\\) 的新思路。 若得到某个平稳分布所对应的马尔可夫链的状态转移矩阵，就很好地可以求出样本集； \\[q(j|i)=N(j|i,σ)\\] 一般不能满足细致平稳性：进一步使得不等号变等号，需要乘以一个接受概率; 截屏2022-05-22 14.07.47 MCMC 直接抽样 拒绝接受抽样 相同点 都采用了直接抽样的思想，MCMC也是基于拒绝接受的方法在不同状态之间转移； 都需要基于一个已知的抽样； 与MCMC一样都需要设置一个拒绝-接受条件 不同点 离散和连续的分布都有效 采样方式简洁易懂，但对于复杂的分布所估计出来的较为粗糙 将一个可直接抽样的分布覆盖未知抽样分布。需要能够找到适合的分布，条件更为苛刻，效率更低 适用场景 适用于数据维（数据特征）$ x_1,x_2x_p$多的数据；对样本独立要求不强的分布 适用于简单的抽样 适用于更为复杂的目标分布 6.6 Gibbs采样 6.6.0.1 重新寻找合适的细致平稳条件 Gibbs是一种特殊的马尔可夫链算法；交替条件采样(alternating conditional sampling)交替指的是Gibbs采样的一种迭代； 已知观测值\\(y\\)，给定一个带有参数的向量\\(\\theta=(\\theta_1,\\theta_2\\cdots,\\theta_d)\\)，若\\(\\theta_j^t,j=1,2,\\cdots,\\)d表示第j个参数\\(\\theta_j\\)在第t次迭代的采样值，则该采样值随机地取自概率分布\\(p(\\theta_j^t|\\theta_1^t,\\cdots,\\theta_{j-1}^t,\\theta_{j+1}^{t-1},\\cdots,\\theta_d^{t-1},y)\\) 6.6.1 Gibbs步骤 仍然是拒绝-接受采样的思想 通过固定其他维度逐一对某一维度进行采样； 关键在于找到合适的转移矩阵； 6.7 重要采样法 \\(I=\\int _Ch(x)dx\\)中积分区域\\(C\\)任意形状，也可能无界；用直接平均值估计效果不好；对于一些样本量过大的来说，使用拒绝接受采样来说是不可取的；考虑非均匀抽样，\\(|h(x)|\\)大的地方密集投放点，就可以有效地投放样本。设\\(g(x),x\\in C\\)为一个密度，其形状与\\(|h(x)|\\)相近，当\\(g(X)=0\\)时\\(h(x)=0\\),当\\(||x||\\to \\infty\\)时候，\\(h(X)=o(g(x))\\) 基本思想：接受拒绝采样时候通过接受拒绝的方式对$ g(X)\\(来得到样本进行筛选；\\)g(X)$就是所说的试投密度或重要抽样密度； 函数\\(f(x)\\)在分布$ p(x)$下的期望可写为： \\[ E_p[f(x)]=\\int_xf(x)p(x)dx \\\\=\\int_xf(x)\\frac{p(x)}{q(x)}q(x)dx \\\\=\\int_xf(x)\\omega(x)q(x)dx \\\\=E_q[f(x)\\omega(x)] \\] 其中：\\(\\omega(x)\\)称为重要性权重；进一步可以用\\(f(x)\\)的样本来估计： \\[ \\hat f_N=\\frac{1}{N}(f(x^{(1)}\\omega(x^{(1)})+\\cdots+f(x^{(N)})\\omega(x^{(N)})) \\] 其中：$ x{(1)},,x{(N)}\\(独立同分布\\)IID～q(x)$中抽出； 重要性采样方法程序； set.seed(1) N &lt;- 10000 Ginv &lt;- function(y) sqrt(1 + 3*y) - 1 X &lt;- Ginv(runif(N)) eta &lt;- exp(X) / (2/3*(1 + X)) I3 &lt;- mean( eta ) var3 &lt;- var(eta) 6.8 分层抽样法 将C上的积分分解为若干个子集的积分，使得\\(h(x)\\)在每一个子集上变化不大，分别计算各个子集的积分再求和，可提高精度； 一个例子 求定积分: \\[ I=\\int _0^1h(x)dx \\] 可以得到\\(I\\)精确值\\(I=0.05\\)，用平均值和分层抽样比较 \\((0,1)\\)区间随机抽取\\(N\\)点用平均值法得到\\(\\hat I_2\\)，其渐近方差为 \\[ Var(\\hat I_2)=\\frac{Var(h(U))}{N}=\\frac {143}{150N} \\] 6.8.0.1 R程序 rm(list=ls()) h&lt;-function(x)ifelse(x&lt;=0.5,1+0.1*x,-1+0.1*x) I.true&lt;-0.5 set.seed(1) N=10000 eta=h(runif(N)) I2&lt;-mean(eta) sd2&lt;-sd(eta) I2 ## [1] 0.0594168 (I2-I.true)/I.true ## [1] -0.8811664 sd2^2 ## [1] 0.9504117 eta1&lt;-h(runif(N/2,0,0.5)) a&lt;-0.5*mean(eta1) eta2&lt;-h(runif(N/2,0.5,1)) b=0.5*mean(eta2) I5=a+b I5 ## [1] 0.05000954 "],["优化算法.html", "Chapter 7 优化算法 7.1 牛顿优化算法 7.2 Quasi-Newton Methods 7.3 BGFS算法（准牛顿算法） 7.4 最优梯度下降算法 7.5 随机梯度下降算法 7.6 Nelder Mead算法（单纯形法）", " Chapter 7 优化算法 7.1 牛顿优化算法 \\[ x_{n+1}=x_n-(\\frac{\\partial^2 f(x)}{\\partial x \\partial x&#39;})^{-1}\\frac{\\partial f(x)}{\\partial x} \\] Rprof 较高波峰和波谷 1. 选择初始猜测点 x0x0，设置 n=0n=0。 2. 按照以下迭代过程进行迭代： xn+1=xn−f′(xn)f′′(xn).xn+1=xn−f′(xn)f′′(xn). 1. 计算 |f′(xn+1)||f′(xn+1)| 1. 如果 |f′(xn+1)|≤ϵ|f′(xn+1)|≤ϵ，停止迭代； 2. 否则，返回第 2 步。 https://blog.csdn.net/zhangdamengcsdn/article/details/80200059 R中求偏导的方法:R使用D() 来求一元函数的导数，用deriv() 来求多元函数的偏导数； 7.2 Quasi-Newton Methods 对于牛顿迭代来说，难以求出二阶导数（样本空间较大时） 取消二阶导，直接运用一介导来求解； 7.3 BGFS算法（准牛顿算法） 以其发明者Byoyden,Fletcher,Goldfarb,Shanno命名； BFGS算法以下算法来近似Hessian矩阵； $ B_kH_k$ Origin: $ B_0=I$ 7.4 最优梯度下降算法 7.4.1 原理 梯度下降的目的，就是为了最小化损失函数 $ L(w,b)=N_{i=1}(y_i-f(wx_i+b))2$ 要控制两个过程：即控制两个参数，输入的信号量的权重（weight/w）另一个为调整函数与真实值距离的偏差（bias，b） 通过梯度下降方法来实现，使得损失函数的值变得越来越小； v2-79eecd15feeaececb8a1b651ed88b6be_1440w 学习率(learning rate) $ w_{i+1}=w_i-$ 7.4.2 梯度下降的过程 更新策略： \\(x_n+1=x_n−α∇f(x_n)\\) 7.5 随机梯度下降算法 梯度下降算法通常收敛速度较慢，因为在每次迭代中对每个样本值都需要计算梯度，在样本量较大时计算量会随之增大。随机梯度下降算法的思想是在算法的每次迭代更新时只考虑一个样本。以线性回归模型为例，就是将梯度下降算法中的 将训练数据随机排序，然后重复第2步直至收敛。 抽取一个随机样本 i∈{1,2,⋯,n}i∈{1,2,⋯,n}，根据下式对 β进行迭代。 β:=β−α∇J(β)i. 7.6 Nelder Mead算法（单纯形法） R中optim()的默认算法； 算法思路：从n维单纯形定点出发（在矩阵上的表示就是非奇异矩阵）；进一步计算每个单纯形点点函数值$ f(x_j)$，从中再选出对于我们迭代过滤的点，即表现最差的点； 进一步计算剩下n个点的中心点，再代入过滤点生成新点： \\[ x_r=x_0+α(x_0−x_n+1) \\] 通常取\\(\\alpha=1\\) 在\\(R^n\\)空间中，一点的迭代通常会有两种情况： 1. \\(f(x1)≤f(xr)&lt;f(xn)\\),\\(f(x1)≤f(xr)&lt;f(xn)\\)，这种情况下xr 既不是最佳点也不是最差点，将 xn+1 替换为xr，形成新的单纯形，回到第一步。 2. f(xr)&lt;f(x1)f(xr)&lt;f(x1)，即 xr 为最佳点，那么在这个方向上继续延伸，得到延伸点（Expansion Point）：通常取\\(\\gamma=2\\) 3. \\(f(xr)≥f(xn)\\),\\(f(xr)≥f(xn)\\)，即 xr 为最差点，这意味着在 xn+1xn+1 和 xrxr 之间可能存在谷点，这时寻找收缩点（contraction point）： "],["贝叶斯统计推断.html", "Chapter 8 贝叶斯统计推断 8.1 理解线性回归", " Chapter 8 贝叶斯统计推断 贝叶斯定理： \\[ P(A|B)=\\frac{P(B|A)P(A)}{P(B)} \\] 其中\\(P(A)\\)为先验概率；\\(P(A|B)\\)是给出事件A之后的认知的概率（后验概率）； \\(P(B|A)/P(B)\\)是事件A对事件B的支持程度，即似然函数； 许多情况下，\\(P(B)=constant\\)y，所以： \\[ P(A|B) \\propto P(B|A)P(A) \\] 1 主观概率与不确定性 不确定的高低用概率来表示，必然包含人们的主观判断； 核函数：https://en.wikipedia.org/wiki/Positive-definite_kernel是作为一种运算技巧(Kernel Function)若\\(\\phi(x)\\)是\\(x\\)在高维的映射，那么我们定义核函数为： \\[ K(x,l)=\\phi(x)^T\\phi(l) \\] 类似的，如果特征维度为 n ，映射的阶数为 d，那我们可以得到的结果是： img 降低了时间复杂度； kernel function 的判定： 根据Mercer定理，任何半正定的函数都可以作为kernel function 8.0.1 常用的kernel function:高斯核函数 高斯核函数可以将原始的特征空间映射到无穷维的特征空间。对于样本\\(\\{x(1),x(2),x(3),\\cdots,x(m)\\}\\)，\\(l\\)的取值是所有的\\(X\\) 8.0.2 极大似然估计 考虑一个M类问题：第m类别的数据子集\\(X_m\\)对应的概率密度函数是\\(p(x|\\omega_m)\\) 需要确定数据的概率分布，需要知道概率分布函数的形式和参数，一个基本假设，概率分布的形式已知，比如满足高斯分布，那么似然函数就可以以参数\\(\\theta\\)来表示，若是高斯分布，参数\\(\\mu_i\\)和\\(\\sigma^2\\)，即\\(\\theta=(\\mu_i,\\sigma^2)\\) 8.0.3 渐近无偏 极大似然是渐近无偏的： \\[ \\lim_{N\\to0}E[\\hat \\theta_{ML}]=\\theta_0 \\] 这里认为的估计值\\(\\hat \\theta\\)本身就是一个随机变量，其均值就是未知参数的真实值，就是渐近无偏； 8.0.4 渐近一致 即：\\(\\lim_{n\\to \\infty}prob\\{||\\hat \\theta_{ML}-\\theta_0\\leq \\epsilon\\}=1\\)满足一致性就不会形成震荡； 8.0.5 最大后验估计 最大似然估计中，将\\(\\theta\\)看作未知参数，而最大后验估计中，将$\\(看作一个随机变量，并在已知样本中估计参数\\)$ img https://bookdown.org/wangminjie/R4DS/bayesian-glm-logistic-binomial.html 8.1 理解线性回归 对于线性回归：可以从频率学派和贝叶斯学派来理解： 频率学派中，weight value \\(\\omega\\)是一个未知的常数，因此可以将其转化为一个最优化问题，对其进行点估计，就是2-范数最小化： 8.1.1 条件分布\\(p(\\omega|Data)\\) 根据贝叶斯原理，后验概率可以由先验概率和似然概率得到： "],["方差缩减技术.html", "Chapter 9 方差缩减技术", " Chapter 9 方差缩减技术 随机模拟有很好的适用性，但仍然有精度低、计算量大的问题；若能够成倍减少随机模拟误差方差，就可以有效减少随机模拟时间。 重要性抽样、分层抽样都是降低随机模拟误差的重要方式。我们以随机变量\\(X\\)的期望\\(\\theta=EX\\)的估计为例，目标在于降低\\(\\theta\\)的估计量的渐进方差。 9.0.1 控制变量法 要估计随机变量\\(X\\)的期望\\(\\theta=EX\\)，从\\(X\\)中抽取\\(N\\)个独立样本值\\(X_1,X_2,\\cdots,X_n\\)，用样本平均值就是你要估计的\\(EX\\)。 另外的随机变量\\(Y\\)满足 \\[ EY=0,Cov(X,Y)&lt;0 \\] 令\\(Z=X+Y\\)，则 \\[ E(Z)=\\theta,Var(Z)=Var(X)+Var(Y)+2Cov(X,Y) \\] 最好地利用\\(Y\\)与\\(X\\)的相关性，令 \\[ Z(b)=X+bY \\] 则 \\[EZ(b)=EX=\\theta\\] \\[ Var(Z(b))=Var(X)+2bCov(X,Y)+b^2Var(Y) \\] 求得\\(Var(Z(b))\\)的关于b的最小值点，得 \\[ b=-Cov(X,Y)/Var(Y)=-\\rho_{X,Y}\\sqrt{Var(X)/Var(Y)} \\] 可见，只要找到零均值随机变量\\(Y\\)使得\\(\\rho_{X,Y}\\neq 0\\)就可以减小\\(EX\\)的估计方差。 9.0.2 对立变量法 补充： 渐近方差： Attributablerisk: "],["社会网络图.html", "Chapter 10 社会网络图 10.1 操作网络数据 10.2 回归模型评估 10.3 预测变量的筛选", " Chapter 10 社会网络图 10.0.1 learning path 10.0.2 layout 布局 设置成特定形状的网络图 另一种是基于各种算法的优化，主要目的是在于均匀分布节点，使边长度均匀，最小化交叉； 10.0.3 颜色选择 colors()命令返回R中所有可能的颜色列表； 10.0.4 节点设置 10.0.5 线条设置 10.0.6 同配性 assortativity 该节点在多大程度上会与同类型或者不同类型的其他节点进行匹配，可以通过一种相关性统计量（所谓的同配系数）进行量化。 10.0.7 聚类系数 Clustering cofficient 三元闭包体现了社会网络的“传递性”（transitivity），枚举所有节点三元组中构成三角形的比值来表征。 10.0.8 模体 网络中的频繁子图模式 网络聚类系数的分布,用来检验社会网路的聚集性上 10.1 操作网络数据 找出R中所有的自建的数据集： print（data（package='fda'）） 进一步使用数据集内的数据： library(mlbench) print(data(package=\"mlbench\")) #实际操作mlbench改为所需package名 caret::createDataPartition() A series of test/training partitions are created using createDataPartition while createResample creates one or more bootstrap samples. createFolds splits the data into kgroups while createTimeSlices creates cross-validation split for series data. groupKFoldsplits the data based on a grouping factor. 10.2 回归模型评估 拟合值\\(\\hat y\\)和实际观测值\\(y\\)之间的差值称为训练误差； \\[ e^t=y_t-\\hat y_t \\\\=y_t-\\hat\\beta_0-\\hat\\beta_1x_{1,t}-\\hat\\beta_2x_{2,t}-\\cdots-\\hat\\beta_kx_{k,t} \\] 其中\\(t=1,\\cdots,T\\)每个残差都是观测值中不可预测的部分； 10.2.1 残差的自相关ACF图 时间序列数据来说，当前观测的变量值很可能与历史时段的变量值相似； 回归拟合：残差会出现自相关效应； 检验方法：Breusch-Godfrey检验；也称为LM检验； 10.2.2 残差变量与残差的关系图 10.2.3 异常值和强影响点 异常值点：对模型的参数估计有重大影响的观测点；强影响点在x方向也是极端的异常值； 异常值：不正确的数据录入引起： 10.2.4 伪回归 不平稳的时间序列会导致伪回归的出现：\\(R^2\\)值和高残差值自相关共存； 预测具有线性趋势和季度虚拟变量的回归：xxxx 模型中没有变量表示第一季度，因其他季度虚拟变量的系数是这些季度与第一季度之间差异的度量； “趋势”“季节”不是R内的实际对象，需要这种方式时，由tslm()自动创建； 10.2.5 干预变量 竞争对手的活动，广告支出等都会对于被预测变量产生影响； 10.2.6 傅立叶级数 10.3 预测变量的筛选 10.3.1 调整可决系数$ R^2$ \\(R^2\\)没有考虑到自由度的影响，在模型中增加任意一个变量，都会导致\\(R^2\\)值增大。 等效方法选择最小平方误差和（SSE）模型： \\[ SSE=\\sum_{t=1}^Te_t^2 \\] 10.3.2 交叉检验 10.3.3 赤池信息准则AIC AIC信息准则即Akaike information criterion，是衡量统计模型拟合优良性(Goodness of fit)的一种标准，由于它为日本统计学家赤池弘次创立和发展的，因此又称赤池信息量准则。它建立在熵的概念基础上，可以权衡所估计模型的复杂度和此模型拟合数据的优良性。 绘制AIC图形，检验预测的准确性： T值较小时候，AIC准则总是倾向于选择更多的预测变量 10.3.4 施瓦茨的贝叶斯信息准则BIC 10.3.5 最佳回归子集 "],["references.html", "References", " References "],["footnotes-and-citations.html", "Chapter 11 Footnotes and citations 11.1 Footnotes 11.2 Citations", " Chapter 11 Footnotes and citations 11.1 Footnotes Footnotes are put inside the square brackets after a caret ^[]. Like this one 1. 11.2 Citations Reference items in your bibliography file(s) using @key. For example, we are using the bookdown package (Xie 2022) (check out the last code chunk in index.Rmd to see how this citation key was added) in this sample book, which was built on top of R Markdown and knitr (Xie 2015) (this citation was added manually in an external file book.bib). Note that the .bib files need to be listed in the index.Rmd with the YAML bibliography key. The RStudio Visual Markdown Editor can also make it easier to insert citations: https://rstudio.github.io/visual-markdown-editing/#/citations "]]
